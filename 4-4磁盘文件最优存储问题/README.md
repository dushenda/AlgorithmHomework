# 磁盘文件最优存储问题
在讨论磁盘文件最优存储之前，先来看一下各种排序算法。
## [桶排序](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/bucket-sort.html)
> 首先出场的我们的主人公小哼，上面这个可爱的娃就是啦。期末考试完了老师要将同学们的分数按照从高到低排序。小哼的班上只有 5 个同学，这 5 个同学分别考了 5 分、3 分、5 分、2 分和 8 分，哎考的真是惨不忍睹（满分是 10 分）。接下来将分数进行从大到小排序，排序后是 8 5 5 3 2。你有没有什么好方法编写一段程序，让计算机随机读入 5 个数然后将这 5 个数从大到小输出？请先想一想，至少想 15 分钟再往下看吧(^__^) 。
> 
> ![picture1.2](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.3.png)
> 
> 我们这里只需借助一个一维数组就可以解决这个问题。请确定你真的仔细想过再往下看哦。
> 
> 首先我们需要申请一个大小为 11 的数组 int a[11]。OK 现在你已经有了 11 个变量，编号从 a[0]~a[10]。刚开始的时候，我们将 a[0]~a[10]都初始化为 0，表示这些分数还都没有人得过。例如 a[0]等于 0 就表示目前还没有人得过 0 分，同理 a[1]等于 0 就表示目前还没有人得过 1 分……a[10]等于 0 就表示目前还没有人得过 10 分。 picture1.3
> 
> 下面开始处理每一个人的分数，第一个人的分数是 5 分，我们就将相对应 a[5]的值在原来的基础增加 1，即将 a[5]的值从 0 改为 1，表示 5 分出现过了一次。
> 
> ![picture1.4](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.4.png)
> 
> 第二个人的分数是 3 分，我们就把相对应 a[3]的值在原来的基础上增加 1，即将 a[3]的值从 0 改为 1，表示 3 分出现过了一次。
> 
> ![picture1.5](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.5.png)
> 
> 注意啦！第三个人的分数也是“5 分”，所以a[5]的值需要在此基础上再增加 1，即将 a[5]的值从 1 改为 2。表示 5 分出现过了两次。
> 
> ![picture1.6](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.6.png)
> 
> 按照刚才的方法处理第四个和第五个人的分数。最终结果就是下面这个图啦。
> 
> ![picture1.7](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.7.png)
> 
> 你发现没有，a[0]~a[10]中的数值其实就是 0 分到 10 分每个分数出现的次数。接下来，我们只需要将出现过的分数打印出来就可以了，出现几次就打印几次，具体如下。 　　a[0]为 0，表示“0”没有出现过，不打印。
> 　　a[1]为 0，表示“1”没有出现过，不打印。
> 　　a[2]为 1，表示“2”出现过 1 次，打印 2。
> 　　a[3]为 1，表示“3”出现过 1 次，打印 3。
> 　　a[4]为 0，表示“4”没有出现过，不打印。
> 　　a[5]为 2，表示“5”出现过 2 次，打印5 5。
> 　　a[6]为 0，表示“6”没有出现过，不打印。
> 　　a[7]为 0，表示“7”没有出现过，不打印。
> 　　a[8]为 1，表示“8”出现过 1 次，打印 8。
> 　　a[9]为 0，表示“9”没有出现过，不打印。
> 　　a[10]为 0，表示“10”没有出现过，不打印。
> 这个算法就好比有 11 个桶，编号从 0-10。每出现一个数，就将对应编号的桶中的放一个小旗子，最后只要数数每个桶中有几个小旗子就 OK 了。例如 2 号桶中有 1 个小旗子，表示 2 出现了一次；3 号桶中有 1 个小旗子，表示 3 出现了一次；5 号桶中有 2 个小旗子，表示 5 出现了两次；8 号桶中有 1 个小旗子，表示 8 出现了一次。
> 
> ![picture1.8](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/1.8.png)
> 
> 现在你可以请尝试一下输入 n 个 0-1000 之间的整数，将他们从大到小排序。提醒一下如果需要对数据范围在 0-1000 之间的整数进行排序，我们需要 1001 个桶，来表示 0-1000 之间每一个数出现的次数，这一点一定要注意。另外此处的每一个桶的作用其实就是“标记”每个数出现的次数，因此我喜欢将之前的数组 a 换个更贴切的名字 book（book 这个单词有记录、标记的意思）
## [冒泡排序](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/bubble-sort.html)
> 简化版的桶排序不仅仅有上一节所遗留的问题，更要命的是：它非常浪费空间！例如需要排序数的范围是 0-2100000000 之间，那你则需要申请 2100000001 个变量，也就是说要写成 int a[2100000001]。因为我们需要用 2100000001 个“桶”来存储 0~2100000000 之间每一个数出现的次数。即便只给你 5 个数进行排序（例如这 5 个数是 1，1912345678，2100000000，18000000 和 912345678），你也仍然需要 2100000001 个“桶”，这真是太浪费了空间了！还有，如果现在需要排序的不再是整数而是一些小数，比如将 5.56789，2.12，1.1，3.123，4.1234 这五个数进行从小大排序又该怎么办呢？现在我们来学习另一种新的排序算法：冒泡排序。它可以很好的解决这两个问题。
> 
> 冒泡排序的基本思想是：每次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来。
> 
> 例如我们需要将 12 35 99 18 76 这 5 个数进行从大到小进行排序。既然是从大到小排序也就是说越小的越靠后，你是不是觉得我在说废话，但是这句话很关键(∩_∩)。
> 
> 首先比较第 1 位和第 2 位的大小，现在第 1 位是 12，第 2 位是 35。发现 12 比 35 要小，因为我们希望越小越靠后嘛，因此需要交换这两个数的位置。交换之后这 5 个数的顺序是 35 12 99 18 76。
> 
> 按照刚才的方法，继续比较第 2 位和第 3 位的大小，第 2 位是 12，第 3 位是 99。12 比 99 要小，因此需要交换这两个数的位置。交换之后这 5 个数的顺序是 35 99 12 18 76。
> 
> 根据刚才的规则，继续比较第 3 位和第 4 位的大小，如果第 3 位比第 4 位小，则交换位置。交换之后这 5 个数的顺序是 35 99 18 12 76。
> 
> 最后，比较第 4 位和第 5 位。4 次比较之后 5 个数的顺序是 35 99 18 76 12。
> 
> 经过 4 次比较后我们发现最小的一个数已经就位（已经在最后一位，请注意 12 这个数的移动过程），是不是很神奇。现在再来回忆一下刚才比较的过程。每次都是比较相邻的两个数，如果后面的数比前面的数大，则交换这两个数的位置。一直比较下去直到最后两个数比较完毕后，最小的数就在最后一个了。就如同是一个气泡，一步一步往后“翻滚”，直到最后一位。所以这个排序的方法有一个很好听的名字“冒泡排序”。
> 
> ![picture2.1](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/2.1.png)
> 
> 说道这里其实我们的排序只将 5 个数中最小的一个归位了。每将一个数归位我们将其称为“一趟”。下面我们将继续重复刚才的过程，将剩下的 4 个数一一归位。
> 
> 好现在开始“第二趟”，目标是将第 2 小的数归位。首先还是先比较第 1 位和第 2 位，如果第 1 位比第 2 位小，则交换位置。交换之后这 5 个数的顺序是 99 35 18 76 12。接下来你应该都会了，依次比较第 2 位和第 3 位，第 3 位和第 4 位。注意此时已经不需要再比较第 4 位和第 5 位。因为在第一趟结束后已经可以确定第 5 位上放的是最小的了。第二趟结束之后这 5 个数的顺序是 99 35 76 18 12。
> 
> “第三趟”也是一样的。第三趟之后这 5 个数的顺序是 99 76 35 18 12。
> 
> 现在到了最后一趟“第四趟”。有的同学又要问了，这不是已经排好了吗？还要继续？当然，这里纯属巧合，你可以用别的数试一试可能就不是了。你能找出这样的数据样例来吗？请试一试。
> 
> “冒泡排序”原理是：每一趟只能确定将一个数归位。即第一趟只能确定将末位上的数（既第 5 位）归位，第二趟只能将倒数第 2 位上的数（既第 4 位）归位，第三趟只能将倒数第 3 位上的数（既第 3 位）归位，而现在前面还有两个位置上的数没有归位，因此我们仍然需要进行“第四趟”。
> 
> “第四趟”只需要比较第 1 位和第 2 位的大小。因为后面三个位置上的数归位了，现在第 1 位是 99，第 2 位是 76，无需交换。这 5 个数的顺序不变仍然是 99 76 35 18 12。到此排序完美结束了，5 个数已经有 4 个数归位，那最后一个数也只能放在第 1 位了。
> 
> 最后我们总结一下：如果有 n 个数进行排序，只需将 n-1 个数归位，也就是说要进行 n-1 趟操作。而“每一趟”都需要从第 1 位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较（已经归位的数你还比较个啥，浪费表情）。
> 
> 这个算法是不是很强悍。记得我每次拍集体照的时候就总是被别人换来换去的，当时特别烦。不知道发明此算法的人当时的灵感是否来源于此。
> 冒泡排序的核心部分是双重嵌套循环。不难看出冒泡排序的时间复杂度是 O(N2)。这是一个非常高的时间复杂度。冒泡排序早在 1956 年就有人开始研究，之后有很多人都尝试过对冒泡排序进行改进，但结果却令人失望。如 Knuth（Donald E. Knuth 中文名为高德纳，1974 年图灵奖获得者）所说：“冒泡排序除了它迷人的名字和导致了某些有趣的理论问题这一事实之外，似乎没有什么值得推荐的。”你可能要问：那还有没有更好的排序算法呢？请期待下周更新——快速排序。
## [快速排序](http://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html)